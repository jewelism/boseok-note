## CSR, SSR
### Client-Side-Rendering && Server-Side-Rendering

react와 vue등의 프론트 라이브러리&프레임워크는 기본적으로 CSR이다. 

create-react-app이나 vue-cli로 프로젝트를 생성해보면, 
helloworld 컴포넌트가 자동으로 생성되고, 프로젝트를 빌드하고 실행하면 
helloworld 컴포넌트가 보일 것이다. 
그런데 프로젝트의 index.html을 찾아서 열어보자. 
아마 <div id="root"></div> 이런 태그와 기본적인 태그들외에는 
특별한 요소가 안보일것이다.. 
그런데 어떻게 helloworld컴포넌트가 그려질까? 

프로젝트를 빌드하면 webpack과 같은 정적파일을 합쳐주고 관리하는등 
여러가지 일을 자동으로 해주는 모듈번들러가 bundle.js를 생성해준다. 
클라이언트가 deploy한 프로젝트의 url로 접근하면, 
bundle.js와 index.html등 정적파일을 클라이언트의 웹브라우저가 전달받는다. 
그리고 클라이언트의 웹브라우저의 js엔진이 bundle.js를 열심히 해석하여 
화면을 렌더링한다. 이런방식이 CSR이다. 
첫페이지에서 js를 로드하고 동적으로 태그를 생성하기때문에 첫페이지로딩이 상대적으로 느리다.
하지만 그후로는 성능이 좋다. js파일내에 모든 페이지 정보가 있기 때문에.. 
그래서 코드스플리팅개념이 등장했다. 
모든페이지정보를 불러오는게 아니라, 
웹팩 설정을 통해 페이지 정보와 기능을 나눠서 로드할수있다. 그러면 당연히 첫 페이지 로드 성능이 좋아진다. 
csr에는 또다른 중요한 단점이 존재한다. 
번들링된 js에 모든 프론트정보가 담기므로, 보안에 신경써야한다.
개인정보나 결제시스텀이 있다면 ssr로 구현하는것이 
당연히 보안적으로 유리하다. 

반대로 SSR은 클라이언트가 url을 요청하면, url에 해당하는 서버에서 
태그들을 열심히 생성해서 클라이언트에 생성한 태그를 리턴한다. 
그러면 클라이언트에서는 생성된 html만 렌더링하면되므로, 초기 로딩속도가 빠르다. 
js로 DOM을 handling하여 화면을 렌더링하는것보다 브라우저가 태그를 파싱해서 렌더링하는것이 빠르다. 
하지만 서버에서 클라이언트들이 볼 페이지를 렌더링하므로 서버과부하를 막기위한 전략이 필요하다 - 캐싱 

제일 좋은 구현 방법은 첫 페이지만 SSR 하고, 나머지 페이지들은 CSR로 구현하는것이 성능적으로는 바람직하다. 
첫페이지 로딩속도는 사용자 접속률에 중요한 영향을 끼치고, 
CSR을 크롤링 할 수 없는 검색엔진이 대부분이기 때문에, 검색해서 보여져야 할 페이지도 SSR을 하는 것이 좋다.
보통 첫 페이지를 검색할 때 많이 보여주기 때문이다. 
